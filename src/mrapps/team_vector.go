package main

//
// a word-count application "plugin" for MapReduce.
//
// go build -buildmode=plugin wc.go
//

import (
	"fmt"
	"sort"
	"strings"
	"unicode"

	"6.5840/mr"
)

type ByValue []WordFreq

// for sorting by key.
func (a ByValue) Len() int           { return len(a) }
func (a ByValue) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByValue) Less(i, j int) bool { return a[i].Value > a[j].Value }

type WordFreq struct {
	Key   string
	Value int
}

// 实现Team Vector, 键值对[filename, word]
func Map(filename string, contents string) []mr.KeyValue {
	// function to detect word separators.
	ff := func(r rune) bool { return !unicode.IsLetter(r) }

	// split contents into an array of words.
	words := strings.FieldsFunc(contents, ff)

	kva := []mr.KeyValue{}
	for _, w := range words {
		kv := mr.KeyValue{filename, w}
		kva = append(kva, kv)
	}
	// fmt.Println(kva)
	return kva
}

// The reduce function is called once for each key generated by Map, with a
// list of that key's string value (merged across all inputs). The return value
// should be a single output value for that key.
func Reduce(key string, values []string) string {
	sort.Strings(values)
	i := 0
	wordFreqs := make([]WordFreq, 0)
	for i < len(values) {
		j := i + 1
		for j < len(values) && values[j] == values[i] {
			j++
		}
		wordFreqs = append(wordFreqs, WordFreq{
			Key:   values[i],
			Value: j - i,
		})
		i = j
	}
	sort.Sort(ByValue(*&wordFreqs))
	// fmt.Println(wordFreqs)
	strs := make([]string, 0)
	j := 0
	for j < 10 && j < len(wordFreqs) {
		// s := fmt.Sprintf("%v %v", wordFreqs[j].Value, wordFreqs[j].Key)
		// fmt.Println(i)
		strs = append(strs, fmt.Sprintf("%v %v", wordFreqs[j].Value, wordFreqs[j].Key))
		j++
	}

	return fmt.Sprintf("%s", strings.Join(strs, ", "))
}
